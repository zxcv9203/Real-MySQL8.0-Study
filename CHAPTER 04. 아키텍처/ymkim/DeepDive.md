### Insert Buffer의 병합이 Non Clustered 인덱스에 대한 삽입을 최적화하는 이유
- Non Clustered 인덱스는 데이터 행과는 별도로 관리되므로, 새로운 행을 삽입할 때마다 인덱스 엔트리의 갱신이 필요하다.
- Insert Buffer는 Non-clustered 인덱스의 업데이트를 즉시 수행하지 않고, 임시적으로 버퍼링한다. 이는 I/O 횟수를 최적화하는 결과로 나타난다.
- Insert Buffer에 쌓인 데이터는 Background Thread에 의해 주기적으로 Primary Index와 병합된다. (시스템이 상대적으로 부하가 낮을 때 수행된다.)
- 쓰기작업을 그때그때 수행하지 않기 때문에 한꺼번에 여러개의 데이터를 쓰게 되고, 결과적으로 더 적은 I/O 작업으로 더 많은 삽입을, 순차적으로 수행할 가능성이 높아진다.

### 버퍼 풀와 Adaptive Hash 인덱스의 역할
버퍼 풀과 Adaptive Hash 인덱스 모두 일종의 캐싱을 수행하여 동시에 데이터 접근 속도를 빠르게 해주는 역할을 수행한다는 공통점을 갖는다.

그렇다면 굳이 이렇게 중복된 두개의 캐싱 구조를 사용하는 이유가 뭘까?

먼저 버퍼 풀에 대한 설명이다, 
- 데이터와 인덱스 페이지를 메모리에 캐싱하는 구조로 동작하며, 소위 말하는 '**버퍼링**'의 역할을 수행한다.
- 이를 통해 디스크 I/O를 줄이고, 데이터 접근 속도를 향상시킬 수 있다. (반복되는 인덱스 페이지를 메모리에 유지하여, 굳이 스토리지 엔진를 경유하지 않도록 한다.)
- B-Tree 구조의 인덱스를 사용한다. 
- Range 쿼리나 Ordered 쿼리에 최적화 되어 있다.
    - `SELECT * FROM table WHERE column BETWEEN value1 AND value2`
    - `Order By`를 사용하는 쿼리

이어서 Adaptive Hash 인덱스에 대한 설명이다.
- 버퍼 풀 위에 더욱 효율적인 데이터 접근을 위해 사용한다고 이해할 수 있다. (사용 패턴을 기반으로 버퍼 풀에 올라온 데이터들에 인덱스를 생성한다고 이해할 수 있겠다)
- 이름에서 알 수 있듯, Hash 구조의 인덱스를 사용한다.
- 특정 키 값에 대한 쿼리에 최적화되어 있다.
    - `SELECT * FROM table WHERE column = value`


### Adaptive Hash 인덱스의 동작 원리
1. 동작 해시 인덱스 생성
- DB 사용 패턴을 기반을 실시간으로 모니터링하며, 특정 데이터에 대한 조회가 빈번하게 발생하는 경우 InnoDB는 이를 감지하고 해당 데이터를 빠르게 접근할 수 있는 해시 인덱스를 동적으로 생성한다.

2. 해시 함수의 사용
- 해시 인덱스는 키 값을 해시 함수에 입력하여 해시된 값을 생성한다. 조회 시 주어진 키 값에 대해 동일한 해시함수를 사용하여 해시된 값을 계산하고 이를 통해 데이터를 찾는다.

3. 버퍼 풀과의 상호작용
- Adaptive Hash 인덱스는 버퍼 풀 내에 저장된 데이터에 대해서만 생성된다. 즉, 메모리에 캐시된 데이터에 대한 인덱스 구조라고 할 수 있다.

4. 등가 비교 최적화
- 해시 인덱스 구조는 등가비교(`WHERE column = value`)에 최적화 되어 있다.
- 반대로 범위가 지정된 쿼리나, 정렬된 데이터 쿼리의 경우에는 B-Tree 인덱스를 타면 더욱 이점이 있다.

### 쿼리 캐시의 한계

1. 비효율적인 쿼리 매칭
MySQL Query Cache는 쿼리의 hash된 값을 linked list에 저장하며 이는 쿼리가 정확하게 일치해야 함을 의미한다 -> 같은 동작을 하더라도 공백 문자 하나라도 다르면 쿼리 캐시 사용 불가

2. 상대적으로 비싼 쿼리들이 혜택을 가장 적게 받음
테이블에 작업이 일어나면 쿼리 캐시에서 해당 테이블을 사용하는 캐시들은 모두 무효화(invalidate)된다. 여러 테이블에 걸쳐 조인이 일어나는 비싼 쿼리들의 경우, 하나의 테이블에서만 변경이 일어나도 캐시가 모두 무효화된다.

3. Cache 관련 작업이 발생하면 Global lock이 발생
Query Cache에 데이터를 추가하거나 무효화(invalidate)하는 작업은 모두 exclusive 잠금을 수행한다. 즉 Query Cache에 대한 모든 잠금은 global mutex가 걸리게되고, mutex가 설정될 때마다 다른 커넥션은 cache 관련 작업의 완료를 대기한다 (`Waiting for query cache lock`).

4. 멀티코어 확장의 어려움
쿼리 캐시는 싱글 코어에서 동작하도록 설계되어, 현재의 멀티 코어 시스템에서 원하는 만큼 처리량이 확장되지 않는다. 멀티 코어 환경에서는 상대적으로 많은 쓰레드가 존재하며, 결국 쿼리 캐시 입장에서 더 많은 경합과 잠금이 발생하여 더 많은 `Waiting for query cache lock` 메세지가 발생하게 된다.

5. 단일 서버에서만 유효
master / slave DB 구조에서 Query Cach를 하게 되면 무효화가 즉시 복제본에 반영되지 않는 문제가 있다.

### 쓰레드 캐시 vs 쓰레드 풀

- 쓰레드 캐시는 Foreground 쓰레드를 캐싱. (연결 시에 활용하는 쓰레드)
- 쓰레드 풀은 Background 쓰레드를 캐싱. (실제 요청을 처리하는 쓰레드)
